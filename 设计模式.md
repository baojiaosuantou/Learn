---


---

<h2 id="设计模式分类"><span class="prefix"></span><span class="content"><strong>设计模式分类</strong></span><span class="suffix"></span></h2>
<p>模式依据其目的可分为创建型（ Creational）、结构型( Structural)、行为型( Behavioral )三种。创建型模式与对象的创建有关；结构型模式处理类或对象的组合；行为型模式对类或对象怎样交互和怎样分配职责进行描述。</p>
<p><a href="https://www.cnblogs.com/Diyo/p/11415588.html#_label1">Java 中几种常用设计模式 - DiYong - 博客园 (cnblogs.com)</a> 由这个分类开始学</p>
<p><a href="https://bbs.huaweicloud.com/blogs/343605">深入理解设计模式！六大设计原则的分析与介绍-云社区-华为云 (huaweicloud.com)</a> 单一原则和开闭原则看了，后面慢慢补充</p>
<h2 id="单例模式"><span class="prefix"></span><span class="content"><strong>单例模式</strong></span><span class="suffix"></span></h2>
<p><strong>1.应用场景？</strong><br>
<a href="https://www.cnblogs.com/damsoft/p/6105122.html">单例模式的优缺点和使用场景 - 晓明的哥哥 - 博客园 (cnblogs.com)</a></p>
<p><strong>2.怎么实现？</strong><br>
<strong>3.懒汉模式为什么有双重检验？</strong><br>
<a href="https://cyber-reed.tech/archives/123/">线程安全的单例为什么要这样写(双重检查) - The Pensieve (cyber-reed.tech)</a></p>
<h2 id="工厂方法模式"><span class="prefix"></span><span class="content"><strong>工厂方法模式</strong></span><span class="suffix"></span></h2>
<p><strong>1.工厂方法模式到底是什么？</strong><br>
工厂方法模式（Factory Method Pattern）是一种创建型设计模式，它提供了一种将对象的创建委托给子类的方式，从而实现了对象的创建与使用的分离。</p>
<p>在工厂方法模式中，我们定义一个抽象工厂接口，该接口声明了一个用于创建产品对象的工厂方法。具体的产品类通过实现抽象工厂接口，并重写工厂方法来创建具体的产品对象。客户端代码通过调用工厂方法来获取产品对象，而不需要直接实例化具体的产品类。</p>
<p>下面是一个简单的例子，演示了工厂方法模式的结构和使用：</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token comment">// 抽象产品类</span>
<span class="token keyword">interface</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体产品类A</span>
<span class="token keyword">class</span> <span class="token class-name">ConcreteProductA</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体产品A的操作"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体产品类B</span>
<span class="token keyword">class</span> <span class="token class-name">ConcreteProductB</span> <span class="token keyword">implements</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体产品B的操作"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 抽象工厂类</span>
<span class="token keyword">interface</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>
    Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体工厂类A</span>
<span class="token keyword">class</span> <span class="token class-name">ConcreteFactoryA</span> <span class="token keyword">implements</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 具体工厂类B</span>
<span class="token keyword">class</span> <span class="token class-name">ConcreteFactoryB</span> <span class="token keyword">implements</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建具体工厂A</span>
        Factory factoryA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactoryA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 使用具体工厂A创建产品对象</span>
        Product productA <span class="token operator">=</span> factoryA<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 调用产品对象的操作方法</span>
        productA<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 创建具体工厂B</span>
        Factory factoryB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFactoryB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 使用具体工厂B创建产品对象</span>
        Product productB <span class="token operator">=</span> factoryB<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 调用产品对象的操作方法</span>
        productB<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>运行以上代码，将输出以下结果：</p>
<pre><code>具体产品A的操作
具体产品B的操作
</code></pre>
<p>从结果可以看出，通过工厂方法模式，我们可以通过具体的工厂来创建相应的产品对象，而不需要直接实例化具体的产品类。这样可以使得客户端代码与具体的产品类解耦，同时也方便扩展和变更产品类的实现。</p>
<p>工厂方法模式适用于以下场景：当客户端代码需要创建一系列相关的产品对象时，可以使用工厂方法模式来统一管理产品的创建过程，提供灵活的扩展性和可维护性。</p>
<p><strong>2.工厂方法模式 和 简单工厂对比，优势是什么？</strong><br>
工厂方法模式和简单工厂模式是两种常见的创建型设计模式，它们都用于对象的创建，但在实现方式和应用场景上有一些不同。</p>
<ol>
<li>
<p>实现方式：</p>
<ul>
<li>简单工厂模式（Simple Factory Pattern）使用一个工厂类来封装对象的创建逻辑。客户端通过传递不同的参数给工厂类来获取不同的产品对象。</li>
<li>工厂方法模式（Factory Method Pattern）将对象的创建委托给子类。每个具体的产品类都有对应的工厂类，客户端通过与工厂接口交互来获取产品对象。</li>
</ul>
</li>
<li>
<p>灵活性：</p>
<ul>
<li>简单工厂模式在增加新产品时，需要修改工厂类的代码，违反了开闭原则。而工厂方法模式通过新增具体工厂类来创建新产品，不需要修改已有代码，满足了开闭原则，具有更好的灵活性和可扩展性。</li>
</ul>
</li>
<li>
<p>可维护性：</p>
<ul>
<li>工厂方法模式的每个具体工厂类只负责创建一个产品对象，符合单一职责原则，使得代码结构清晰，易于维护。</li>
<li>简单工厂模式的工厂类负责创建多个产品对象，可能包含大量的条件判断语句，代码结构较为复杂，不易于维护。</li>
</ul>
</li>
<li>
<p>扩展性：</p>
<ul>
<li>工厂方法模式支持新增产品时只需添加具体工厂类和具体产品类，无需修改已有代码，方便扩展。</li>
<li>简单工厂模式需要修改工厂类的代码来添加新产品，违反了开闭原则，扩展性较差。</li>
</ul>
</li>
</ol>
<p>总结来说，工厂方法模式相对于简单工厂模式具有更好的灵活性、可维护性和扩展性。尽管工厂方法模式的实现会稍微复杂一些，但它能够更好地满足开闭原则，更适合在需要创建一系列相关产品对象的场景中使用。</p>
<p><strong>3.开闭原则和单一职责原则？</strong><br>
开闭原则（Open-Closed Principle，OCP）和单一职责原则（Single Responsibility Principle，SRP）都是面向对象设计中的重要原则，它们对于代码的可维护性、可扩展性和复用性具有重要意义。</p>
<ol>
<li>
<p>开闭原则（OCP）：</p>
<ul>
<li>定义：开闭原则是指软件实体（类、模块、函数等）应该对扩展开放，对修改关闭。即在不修改已有代码的情况下，通过增加新的代码来扩展功能。</li>
<li>目标：通过遵循开闭原则，可以使系统更加稳定，减少修改已有代码所带来的风险，并且可以方便地扩展和修改系统的功能。</li>
<li>实践：为了满足开闭原则，我们可以使用抽象和多态的特性，通过接口或基类来定义抽象的行为，具体的实现通过子类或实现类来完成。当需要新增功能时，只需创建新的子类或实现类，而不需要修改已有的代码。</li>
</ul>
</li>
<li>
<p>单一职责原则（SRP）：</p>
<ul>
<li>定义：单一职责原则是指一个类或模块应该只有一个引起它变化的原因。即一个类或模块只负责完成一个明确的功能或职责。</li>
<li>目标：通过遵循单一职责原则，可以使类或模块的职责更加明确，降低类的复杂度，提高类的可读性和可维护性。</li>
<li>实践：为了满足单一职责原则，我们应该将不同的功能拆分为不同的类或模块，每个类或模块只负责完成一个特定的功能。当需求发生变化时，只需修改与该功能相关的类或模块，而不会影响到其他部分的代码。</li>
</ul>
</li>
</ol>
<p>综上所述，开闭原则和单一职责原则都是为了提高代码的可维护性和可扩展性。开闭原则强调通过扩展来实现功能的增加，而不是修改已有的代码。单一职责原则强调一个类或模块只负责完成一个明确的功能，避免职责的混淆和耦合。</p>
<p>遵循这两个原则可以使代码更加稳定、易于理解和维护，并且方便扩展和修改功能。同时，这两个原则也是面向对象设计中的基本原则，是良好的设计实践的基础。</p>
<p><strong>4.现有技术中，用到了工厂方法模式的有哪些？</strong><br>
工厂方法模式是一种常用的设计模式，在现有的技术中有许多应用。以下是一些常见的应用场景和技术：</p>
<ol>
<li>
<p>Java中的Collection接口：Java中的Collection接口定义了一组操作集合元素的方法，而具体的集合类（如ArrayList、LinkedList等）则实现了这个接口。通过Collection接口的工厂方法<code>Collection&lt;T&gt; collection = new ArrayList&lt;&gt;()</code>，可以根据需要选择不同的集合类来创建集合对象。</p>
</li>
<li>
<p>Spring框架中的BeanFactory：Spring框架使用了工厂方法模式来管理和创建Bean对象。在Spring中，通过配置文件或注解的方式定义Bean的信息，然后通过BeanFactory接口的工厂方法来获取具体的Bean对象。</p>
</li>
<li>
<p>Android中的LayoutInflater：Android开发中，我们经常需要动态地创建和管理界面视图。Android的LayoutInflater类就使用了工厂方法模式，它通过工厂方法来创建界面视图的各种组件，如布局、按钮、文本框等。</p>
</li>
<li>
<p>JDBC中的DriverManager：JDBC（Java Database Connectivity）是Java提供的用于数据库访问的API。在JDBC中，DriverManager类使用了工厂方法模式，通过工厂方法来创建和管理数据库驱动程序对象。</p>
</li>
<li>
<p>日志框架中的Logger：许多日志框架（如Log4j、Slf4j等）都使用了工厂方法模式来创建Logger对象。通过工厂方法，可以根据需要选择不同的日志实现（如文件日志、数据库日志等）。</p>
</li>
</ol>
<p>这些只是工厂方法模式在现有技术中的一些应用示例，实际上工厂方法模式在各种领域和技术中都有广泛的应用。通过使用工厂方法模式，可以实现对象的创建与使用的分离，提高代码的灵活性、可扩展性和可维护性。</p>
<p><strong>Java中的Collection接口详解</strong><br>
在Java中，Collection接口通过工厂方法模式来创建具体的集合实例。工厂方法模式是一种创建型设计模式，它将对象的创建委托给子类或工厂类，而不是直接在代码中使用new关键字来实例化对象。</p>
<p>ArrayList是Collection接口的一个具体实现类，下面是使用工厂方法模式创建ArrayList实例的示例代码：</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span>
<span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CollectionFactoryExample</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用工厂方法创建ArrayList实例</span>
        Collection<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> collection <span class="token operator">=</span> <span class="token function">createCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 添加元素</span>
        collection<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        collection<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"banana"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        collection<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"orange"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 遍历集合元素</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>String fruit <span class="token operator">:</span> collection<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fruit<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 工厂方法创建ArrayList实例</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> Collection<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> <span class="token function">createCollection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>在上述示例中，我们定义了一个静态的<code>createCollection()</code>方法，该方法返回一个Collection接口的实例。在这个方法中，我们使用<code>new ArrayList&lt;&gt;()</code>来创建一个ArrayList实例并返回。通过这种方式，我们将具体的实现类与客户端代码解耦，使得客户端只需要关注Collection接口的操作，而不需要直接依赖于具体的实现类。</p>
<p>使用工厂方法创建ArrayList实例与直接使用<code>new ArrayList()</code>的区别在于灵活性和可扩展性。</p>
<ol>
<li>
<p>灵活性：通过工厂方法创建ArrayList实例，可以将具体的实现类与客户端代码解耦。客户端只需要关注Collection接口的操作，而不需要直接依赖于具体的实现类。这样，如果将来需要更换具体的实现类，比如将ArrayList替换为LinkedList，只需修改工厂方法的实现，而不需要修改客户端代码。</p>
</li>
<li>
<p>可扩展性：通过工厂方法创建ArrayList实例，可以在工厂方法中添加一些额外的逻辑来定制化地创建对象。例如，我们可以在工厂方法中添加一些初始化操作，或者在特定条件下返回不同的实现类的实例。这样可以根据具体的业务需求来定制创建对象的过程，提高代码的灵活性和可扩展性。</p>
</li>
</ol>
<p>另外，使用工厂方法还可以隐藏具体实现类的细节，使得客户端只需要与Collection接口进行交互，而不需要了解具体的实现细节。这样可以提高代码的封装性和抽象性。</p>
<p>总结来说，使用工厂方法创建ArrayList实例相较于直接使用<code>new ArrayList()</code>，可以提供更好的灵活性、可扩展性和封装性，使得代码更加可维护和可复用。</p>

